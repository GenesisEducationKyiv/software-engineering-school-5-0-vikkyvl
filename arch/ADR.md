## ADR-001: Вибір підходу для міжсервісної комунікації

### Статус: Прийнято
### Дата: 2025-05-15
### Автор: Victoria Leshchenko

## Контекст
Оскільки використовується мікросервісна архітектура, потрібно обрати механізм для міжсервісної комунікації:

- Забезпечення **асинхронного обміну повідомленнями** між компонентами системи.
- Можливість **масштабування** системи.
- Зменшення **залежностей** між сервісами.
 

## Розглянуті варіанти
1. **RabbitMQ**

   - **Переваги:**
     - Підтримка асинхронної комунікації.
     - Вбудована підтримка кількох протоколів, таких як AMQP, MQTT, STOMP.
     - Легка інтеграція з NestJS через вбудований транспорт <code>Transport.PRQ</code>.
     - Основна увага приділяється надійній доставці та гнучкій маршрутизації повідомлень.
   - **Недоліки:**
      - Може стати вузьким місцем при високих навантаженнях.
      - Не зберігає історію повідомлень.
2. **Apache Kafka**

   - **Переваги:**
      - Асинхронна міжсервісна комунікація.
      - Події не зникають після прочитання, тому їх можна читати багато разів.
      - Горизонтальне масштабування, тобто дозволяє обробляти великі обсяги даних.
      - Підходить для аналітики.
   - **Недоліки:**
      - Складніше налаштування та управління.
      - Надмірна складність для простих сценаріїв.

3. **HTTP / REST**

   - **Переваги:**
      - Найпростіший і найпоширеніший спосіб взаємодії мікросервісів.
      - Легше налагоджувати і тестувати.
   - **Недоліки:**
     - Синхронна комунікація.
     - Залежність від доступності інших сервісів, тобто якщо один сервіс недоступний, інші не зможуть працювати.
     - Не підходить для обробки великих обсягів даних або високих навантажень.

4. **gRPC(Google Remote Procedure Call)**

   - **Переваги:**
      - Висока продуктивність завдяки використанню протоколу HTTP/2(можливість стрімінгу та двосторонньої комунікації) та формату передачі даних Protocol Buffers(швидший і компактніший за JSON).
      - Сувора типізація даних завдяки використанню <code>.proto</code> файлів(опис методів, аргументів та відповідей).
   - **Недоліки:**
     - Синхронна комунікація, що може призвести до затримок у відповідях.
     - Обмежена підтримка браузерами, оскільки gRPC використовує HTTP/2, який не підтримується у всіх браузерах.
     
   
## Прийняте рішення
Було обрано **RabbitMQ як Message Broker** для асинхронної взаємодії між сервісами, оскільки саме цей посередник є швидким, забезпечує надійну доставку та відповідає поставленим вимогам. Надається справді баланс між продуктивністю, простою інтеграціє та гнучкістю маршрутизації повідомлень.

## Наслідки
## Переваги
- Низька затримка: RabbitMQ забезпечує високу продуктивність та швидкість доставки повідомлень.
- Надійна доставка повідомлень: RabbitMQ гарантує, що повідомлення будуть доставлені навіть у випадку збою одного з мікросервісів.
- Легко інтегрується з NestJS: наприклад, кожен мікросервіс слухає певні черги через декоратора <code>@MessagePattern(...)</code>.
- Наявність інтерфейсу для моніторингу стану черг та повідомлень.
- Підтримка JSON-формату.
## Недоліки
- Необхідно окремий контейнер для RabbitMQ.
- Важче відслідтковувати помилки(потрібен логгер).
- Потрібно вручну реалізовувати логіку таймаутів, якщо не отримали відповідь від сервісу.

